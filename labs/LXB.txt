LXB
=============================
3-1
a)

1   Executable programs or shell commands
2   System calls (functions provided by the kernel)
3   Library calls (functions within program libraries)
4   Special files (usually found in /dev)
5   File formats and conventions eg /etc/passwd
6   Games
7   Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)
8   System administration commands (usually only for root)
9   Kernel routines [Non standard]

b) Section 1
c) Section 5
d) Section 8

4-1
a) command argument argument
b) command [runtime options goes here]... [optional input stream[optional output stream]]
c) command [-available runtime flags w/o further arguments] [-S flag needs argument (filename suffix)] [optional output name]
d) Three possible invokation syntaxes:
     command [runtime option] argument argument
     command [runtime option] [-u-flag argument] [-r-flag argument] argument
     command [runtime option] --reference-flag=argument argument

4-2
a) A brief briefing of what the entry is about, i.e. for an executable - what the executable' function is.
b) Section 1
c) Under "SEE ALSO" 
d) Section 1, usually a subsection

4-3
a) man -a <search term> 
b) man -k <keyword>

4-4
a) It lists info about files in a given search path.
b) -l
c) Adds recursive directory search (lists subdirectories and their content as well).

5-1
a) ./ssh/, ssh/, ../bin/ssh/ 
b) ../../bin/ssh/

6-1
a) chmod ugo+rw-x,go-wx <file>
b) chmod g-w <file>
c) chmod ug+x foo

7-1
a) rw-rw-rw-
b) rwxrwx---
c) rw-r-----
d) r--r--r--

7-2
-R, --recursive

7-3
Allows entering the directory and listing of its content.

7-4
(c) is the most suitable one, as it doesn't change possibly existing executive permissions for [ug]. (a) would remove any executive permissions on all files (and directories, making them inaccessible) for anyone, and (b) would add executive permissions for [ug] to all files and directories in the tree.

8-1
# chown user:group -R <path>

9-{1,2,3}
1) Changes current work directory to the parent directory.
2) Changes current work directory to the parent directory of the parent directory.
3) Current directory content in the format:
   filemode <> user group filesize(bytes) modification_time filename[entry type indicator]

9-4
Character special file, e.g. pipes, ports, devices etc ...

9-5
rename file a to 'b'.

9-6
cp -a /dir1/*.* /dir2/

9-7
$ chown root:wheel secret && chmod 640 secret

10-2
/bin/bash
	The bash executable
/etc/profile
	The systemwide initialization file, executed for login shells
/etc/bash.bashrc
	The systemwide per-interactive-shell startup file
/etc/bash.bash.logout
	The systemwide login shell cleanup file, executed when a login shell exits
~/.bash_profile
	The personal initialization file, executed for login shells
~/.bashrc
	The individual per-interactive-shell startup file
~/.bash_logout
	The individual login shell cleanup file, executed when a login shell exits
~/.inputrc
	Individual readline initialization file

11-1
PATH=/bin:/sbin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl

$PATH is a list of paths from where the shell will recognize executables. Executables in $PATH can be executed from any search path without writing the full path to the executable.

11-2
$HOME is the user "default" directory. Here the users document, user-specific configurations etc. are stored.

11-3
$ sed -i "s|$PATH|${PATH}':/data/kurs/adit/bin:/data/kurs/TDDI41/bin'|g" ~/.bash_profile

12-1
stdout:			stderr:
   file1 console	   file1 console
a  y	 n 		a  n     y
b  y     n		b  y     n
c  y	 n		c  n	 y

13-1
a) List directory content, select only the lines which contains the ordered character set "doc" ignoring upper/lower case.
b) Redirects stderr output of "command" to stdout which is then parsed for "fail" (ignoring u/l case)
c) As b, but will also put the output into The Great Void, which of course does jack shit. So, this example is either a typo or intended to raise awareness about the importance of proper syntax. Would we change the line to
$ command >/dev/null 2>&1 | grep -i fail
then we would trash all output apart from successful output from grep.

13-2
a) $ ls -aR ~ > /tmp/HOMEFILES
b) # find / -perm -0002 -type f 2>/dev/null

14-2
$ ping 127.0.0.1 >/dev/null&
kill $(ps -Ao pid=,comm --no-headers | grep ping | grep -o -E '[0-9]+')
(Or, just "ps", look for ping, send "kill <found PID>"), but that's a rather boring way, isn't it? ;)

14-3
$ kill -9 <pid>
This line sends SIGKILL to the process with given PID. This can not be caught or ignored by the process.
$ kill -9 -1
This line sends SIGKILL to all processes with a PID larger than 1, i.e. every process apart from the init process started by the boot manager.

14-4
$ pkill ping

16-{1,2,3,4}
BOF: g
EOF: G
forward search: /option
backward search: ?option

16-5
a) For security reasons, X11Forwarding is disabled by default in many decent distros, but Debian's openssh-server package has it enabled by default.
b) A working xorg server (xserver-xorg) at a bare minimum, plus of course any related packages for whatever functionality is needed.

17-1 (optional)
sed -i "s/'bin/tcsh'/'bin/sh'/g" /etc/passwd

17-2 (optional)
$ paste passwd shadow | expand $(awk 'n<length {n=length} END {print n+1}')
Easier done with:
$ pr -mtw 150 passwd shadow > file1

18-1
Prints the last 10 lines of /var/log/syslog

18-2
$ cat /var/log/syslog | grep cron


Part 5 Errata:
The default configuration for most contemporary distributions is systemd, regardless of what one thinks of that. Sure, sysvinit might be a reasonable (at least you can reason wether it is or not ...) choice regarding this course, but that does not change the fact that the major distributions likely to be found in a professional environment (Debian, Fedora, SUSE, Red Hat, *buntu, Mint)- except for legacy systems - are not running sysvinit.

19-1
bootlogs, syslog, cron, rmnologin, stopbootlogs

19-2
$ systemctl restart sshd.service
-bash: systemctl: command not found

Oh right, old habits die hard ... :p
$ /etc/init.d/ssh restart

20-1
see 12-1 b/c

20-2
$ kill $(ps -Ao pid=,comm --no-headers | grep ping | grep -o -E '[0-9]+')

20-3
# ~/.aliases
gzless() {
  gunzip -c $1 | less
}

20-4
a)
$ (sleep 3; echo PASSWD; sleep 1; echo ls; sleep 1) |\
   socat - EXEC:'ssh -l USER remote.ip.addr',pty,setsid,ctty

"echo ls" could of course be replaced either with a loop over a local script, or executing a remote script.

b)
########

20-5
#!/bin/bash

for OLD in `find $1 -depth`
do
   NEW=`dirname "${OLD}"`/`basename "${OLD}" | tr '[A-Z ]' '[a-z ]'`
   if [ "${OLD}" != "${NEW}" ]
   then
	[ ! -e "${NEW}" ] && mv -T "${OLD}" "${NEW}" \
	|| echo "Could not rename ${OLD}. ${NEW} already exists."
   fi
done

20-6
see 17-2

20-7
# find ./ -type f | xargs grep "$oldip" 2>/dev/null
...where $oldip is the IP-address we are looking for, of course.

20-8
# find /etc -type f -exec sed -i "s|$OLD|$NEW|g" {} \;

20-9
Avoiding password login would be done through pubkey-based access:

#/etc/ssh/sshd_config
 PasswordAuthentication no
 PermitEmptyPasswords no
 RSAAuthentication yes
 DSAAuthentication yes
 HostKey <key path>
 [...]
#EOF

Generating and importing keys ...

Once sorted (phew), and supposing we have the computers defined in /etc/hosts,  we'll simply run

$ for client in `seq 0001 2000`
do
ssh user@$client <<'FOOXECUTETHIS
w
FOOXECUTETHIS
done

